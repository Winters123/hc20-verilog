`timescale 1ns / 1ps

module axi_lite_slave #(
	parameter integer C_S_AXI_DATA_WIDTH = 32,
	parameter integer C_S_AXI_ADDR_WIDTH = 4
)
(
	input									s_axi_aclk,
	input									s_axi_resetn,
	input [C_S_AXI_ADDR_WIDTH-1:0]			s_axi_awaddr,
	input									s_axi_awvalid,
	input [C_S_AXI_DATA_WIDTH-1:0]			s_axi_wdata,
	input [C_S_AXI_DATA_WIDTH/8-1:0]		s_axi_wstrb,
	input									s_axi_wvalid,
	input									s_axi_bready,
	input [C_S_AXI_ADDR_WIDTH-1:0]			s_axi_araddr,
	input									s_axi_arvalid,
	input									s_axi_rready,
	output									s_axi_arready,
	output [C_S_AXI_DATA_WIDTH-1:0]			s_axi_rdata,
	output [1:0]							s_axi_rresp,
	output									s_axi_rvalid,
	output									s_axi_wready,
	output [1:0]							s_axi_bresp,
	output									s_axi_bvalid,
	output									s_axi_awready
);

// AXI4 LITE signals

reg axi_awready;
reg axi_wready;
reg axi_bvalid;
reg axi_arready;
reg [C_S_AXI_DATA_WIDTH-1:0] axi_rdata;
reg axi_rvalid;

// memory
localparam integer NUM_REG_MEM = 16;
localparam integer DW = C_S_AXI_DATA_WIDTH;
reg [DW-1:0] slv_mem[0:NUM_REG_MEM-1];

// I/O connection assignments
assign s_axi_awready = axi_awready;
assign s_axi_wready = axi_wready;
assign s_axi_bresp = 2'b00;
assign s_axi_bvalid = axi_bvalid;
assign s_axi_arready = axi_arready;
assign s_axi_rdata = axi_rdata;
assign s_axi_rresp = 2'b00;
assign s_axi_rvalid = axi_rvalid;

/*
*
* Read Processing
*
*/
wire valid_read_request;
wire read_response_stall;

assign valid_read_request = s_axi_arvalid || !s_axi_arready;
assign read_response_stall = s_axi_rvalid && !s_axi_rready;

initial axi_rvalid = 1'b0;
always @ (posedge s_axi_aclk) begin
	if (!s_axi_resetn)
		axi_rvalid <= 0;
	else if (read_response_stall)
		// need to stay valid as long as the return path is stalled
		axi_rvalid <= 1'b1;
	else if (valid_read_request)
		axi_rvalid <= 1'b1;
	else
		// any stall has been cleared
		axi_rvalid <= 1'b0;
end

reg [C_S_AXI_ADDR_WIDTH-1:0] pre_raddr, rd_addr;

// buffer the address
always @ (posedge s_axi_aclk) begin
	if (s_axi_arready)
		pre_raddr <= s_axi_araddr;
end

always @ (*) begin
	if (!axi_arready)
		rd_addr = pre_raddr;
	else
		rd_addr = s_axi_araddr;
end

// read data
always @ (posedge s_axi_aclk) begin
	if (!read_response_stall && valid_read_request)
		axi_rdata <= slv_mem[rd_addr];
end


// read address chanell ready signal
initial axi_arready = 1'b0;
always @ (posedge s_axi_aclk) begin
	if (!s_axi_resetn)
		axi_arready <= 1'b1;
	else if (read_response_stall) begin
		// outgoing channel is stalled, as long as something is
		// already in the buffer, axi_arready needs to stay low
		axi_arready <= !valid_read_request;
	end
	else 
		axi_arready <= 1'b1;
end


/*
*
* Write Processing
*
*/
reg [C_S_AXI_ADDR_WIDTH-1:0] pre_waddr, waddr;
reg [C_S_AXI_DATA_WIDTH-1:0] pre_wdata, wdata;
reg [(C_S_AXI_DATA_WIDTH/8)-1:0] pre_wstrb, wstrb;

wire valid_write_address;
wire valid_write_data;
wire write_response_stall;

assign valid_write_address = s_axi_awvalid || !axi_awready;
assign valid_write_data = s_axi_wvalid || !axi_wready;
assign write_response_stall = s_axi_bvalid && (s_axi_bready==0);


// the write address channel ready signal
//

initial axi_awready = 1'b1;
always @ (posedge s_axi_aclk) begin
	if (!s_axi_resetn)
		axi_awready <= 1'b1;
	else if (write_response_stall) begin
		// the output channel is stalled 
		// if our buffer is full, we need to remain stalled
		// likewise if it is empty, and there is a request,
		// we will need to stall
		axi_awready <= !valid_write_address;
	end
	else if (valid_write_data) begin
		// the output channel is clear, and write data is available
		axi_awready <= 1'b1;
	end
	else
		axi_awready <= (axi_awready)&&(!s_axi_awvalid);
end

// the write data channel ready signal

initial axi_wready = 1'b1;
always @ (posedge s_axi_aclk) begin
	if (!s_axi_resetn)
		axi_wready <= 1'b1;
	else if (write_response_stall)
		// the output channel is stalled
		// we can remain ready until valid write data shows up
		axi_wready <= !valid_write_data;
	else if (valid_write_address)
		// the output channel is clear, and a write address is available
		axi_wready <= 1'b1;
	else
		// remain ready
		axi_wready <= (axi_wready)&&(!s_axi_wvalid);
end

// buffer the address
always @ (posedge s_axi_aclk) begin
	if (s_axi_awready)
		pre_waddr <= s_axi_awaddr;
end

// buffer the data
always @ (posedge s_axi_aclk) begin
	if (s_axi_wready) begin
		pre_wdata <= s_axi_wdata;
		pre_wstrb <= s_axi_wstrb;
	end
end

always @ (*) begin
	if (!axi_awready)
		waddr = pre_waddr;
	else
		waddr = s_axi_awaddr;
end

always @ (*) begin
	if (!axi_wready) begin
		wstrb = pre_wstrb;
		wdata = pre_wdata;
	end
	else begin
		wstrb = s_axi_wstrb;
		wdata = s_axi_wdata;
	end
end

// write data to slv_mem
always @ (posedge s_axi_aclk) begin
	if (!write_response_stall
			&& valid_write_address 
			&& valid_write_data) begin
		if (wstrb[0])
			slv_mem[waddr][7:0] <= wdata[7:0];
		if (wstrb[1])
			slv_mem[waddr][15:8] <= wdata[15:8];
		if (wstrb[2])
			slv_mem[waddr][23:16] <= wdata[23:16];
		if (wstrb[3])
			slv_mem[waddr][31:24] <= wdata[31:24];
	end
end

// write response channel valid signal
initial axi_bvalid = 1'b0;
always @ (posedge s_axi_aclk) begin
	if (!s_axi_resetn)
		axi_bvalid <= 1'b0;
	else if (valid_write_address && valid_write_data)
		axi_bvalid <= 1'b1;
	else if (s_axi_bready)
		axi_bvalid <= 1'b0;
	else 
		axi_bvalid <= 1'b0;
end

endmodule
